#!/bin/bash
################################################################################
# Loading configuration
################################################################################

CVC_ScriptRootDir=$(dirname "$0")
source "${CVC_ScriptRootDir}/config.inc"

# Initializing the output buffer
declare -a CVC_OutputBuffer

# Initialing internal storage variables
# Those variables are needed to generate dynamic comments such as album names.
declare -a CVCData_Characters
declare -a CVCData_Choirs
declare -a CVCData_Conductors
declare -a CVCData_Incipits
declare -a CVCData_Instrumentalists
declare -a CVCData_Orchestras
declare -a CVCData_PerformancePlace
declare -a CVCData_PerformanceYear
declare -a CVCData_ReleaseYear
declare -a CVCData_SliceTypes
declare -a CVCData_SliceNumbers
declare -a CVCData_SliceTitles
declare -a CVCData_Soloists
declare -a CVCData_WorkTitle
declare -a CVCData_WorkTitleSort

# Initializing the hash table storing constants
declare -A CVC_Constants

################################################################################
# Documentation
################################################################################

# Return code reference
# 1     Syntax error in invocation
# 2     Missing argument
# 3     Target CVC file does not exist
# 4     Unknown inclusion directive
# 5     Unknown alias
# 6     Invalid line
# 11    Constant substitution failure: unknown constant
# 16    Internal error

# Show usage
function usage {
    echo "Converts a Cascaded Vorbis Comments (CVC) file to a set of Vorbis Comments."
    echo "The resulting Vorbis Comments are sent to standard output."
    echo ""
    echo "Usage: cvcexpand [-h] [-l <lang>] [-v] <file>"
    echo ""
    echo "Options:"
    echo "-h            Show this message."
    echo "-l <lang>     An optional target language code. If specified, Vorbis Comments"
    echo "              belonging to other languages will be stripped out from the output."
    echo "-v            Verbose mode. Verbose messages are sent to stderr."
    echo ""
    echo "Arguments:"
    echo "<file>        The name of the CVC file to expand."
}

################################################################################
# Option and argument parsing
################################################################################

# Default values
OPT_TargetLanguage="${CFG_CVCExpand_DefaultLanguage}"

# Calling option parser
while getopts ":hl:v" option; do
    case "${option}" in
        # -h: Help
        h)
            usage
            exit
            ;;

        # -l: Language
        l)
            OPT_TargetLanguage="${OPTARG}"
            ;;

        # -v: Verbose mode
        v)
            OPT_Verbose=1
            ;;

        # Syntax error
        \?)
            >&2 echo "ERROR: Invalid option: -${OPTARG}"
            usage
            [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 1 || exit 1
            ;;

        # Syntax error
        :)
            >&2 echo "ERROR: Option -${OPTARG} requires an argument."
            usage
            [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 1 || exit 1
            ;;

        # Any other value is an internal error
        *)
            >&2 echo "ERROR: Internal getopts error."
            [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 16 || exit 16
            ;;
    esac
done

shift $((OPTIND-1))

# Checking whether a CVC file was supplied as an argument.
if [ -z "$1" ]
then
    >&2 echo "ERROR: No CVC file specified."
    usage
    [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 2 || exit 2
fi

# Abstracting supplied arguments
targetCVCFile="$1"

# Checking whether the supplied CVC file does exist
if [ ! -f "${targetCVCFile}" ]
then
    >&2 echo "ERROR: The CVC file ${targetCVCFile} does not exist!"
    [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 3 || exit 3
fi

# We store the path to the root CVC file to be able to detect the end
# of recursive calls.
if [ -z "${CVC_RootCVCFile}" ]
then
    CVC_RootCVCFile="${targetCVCFile}"
fi

################################################################################
# Internal routines
################################################################################

# Replace constant references with actual data in a value string.
function cvc::substituteConstants {

    if [ -z "$1" ]
    then
        >&2 echo "ERROR: Internal error: Bad substitution call."
        [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 16 || exit 16
    fi

    value="${1}"

    # Extracting symbols
    matches=($(echo "${value}" | grep -oP '\{\{.*?\}\}'))

    # Performing substitution
    for match in "${matches[@]}"; do
        constantName="${match#\{\{}"
        constantName="${constantName%\}\}}"

        if [ "${CVC_Constants[$constantName]}" ]
        then
            [ "${OPT_Verbose}" ] && >&2 echo "Retrieving constant '${constantName}'"
            replacement="${CVC_Constants[$constantName]}"
            value="${value//$match/$replacement}"
        else
            >&2 echo "ERROR: Unable to perform substitution as the constant is unknown."
            >&2 echo "Unknown constant: '${constantName}'"
            [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 11 || exit 11
        fi

    done

    # Returning the result
    echo "${value}"
}

################################################################################
# Processing file content
################################################################################

function processLine {

    #---------------------------------------------------------------------------
    # If the line is an inclusion directive, we process it here.
    #---------------------------------------------------------------------------
    if [[ "${line}" =~ ^@.* ]] && [[ $line == *"="* ]]
    then

        # Generating directive properties
        directive=${line%*=*}
        value=${line#$directive=}

        # Performing constant subtitution
        value=$(cvc::substituteConstants "${value}")

        # Generic @INCLUDE inclusion directive
        if [ "$directive" == "@INCLUDE" ]
        then
            # Checking whether the file path is absolute or relative
            if [[ "$value" =~ ^/.* ]]
            then
                nextFileToInclude=${value}
            else
                local currentFileDirname=$(dirname "${currentFile}")
                nextFileToInclude="${currentFileDirname}/${value}.${CFG_FileExtensions_CVC}"
            fi

            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found an @INCLUDE directive for file ${nextFileToInclude}"

        # @CHOIR inclusion directive
        elif [ "$directive" == "@CHOIR" ]
        then
            nextFileToInclude="${CFG_IncludePath_CHOIR}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @CHOIR directive pointing towards ${nextFileToInclude}"

        # @COMPOSER inclusion directive
        elif [ "$directive" == "@COMPOSER" ]
        then
            nextFileToInclude="${CFG_IncludePath_COMPOSER}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @COMPOSER directive pointing towards ${nextFileToInclude}"

        # @CONDUCTOR inclusion directive
        elif [ "$directive" == "@CONDUCTOR" ]
        then
            nextFileToInclude="${CFG_IncludePath_CONDUCTOR}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @CONDUCTOR directive pointing towards ${nextFileToInclude}"

        # @INSTRUMENT inclusion directive
        elif [ "$directive" == "@INSTRUMENT" ]
        then
            nextFileToInclude="${CFG_IncludePath_INSTRUMENT}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @INSTRUMENT directive pointing towards ${nextFileToInclude}"

        # @INSTRUMENTALIST inclusion directive
        elif [ "$directive" == "@INSTRUMENTALIST" ]
        then
            nextFileToInclude="${CFG_IncludePath_INSTRUMENTALIST}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @INSTRUMENTALIST directive pointing towards ${nextFileToInclude}"

        # @LABEL inclusion directive
        elif [ "$directive" == "@LABEL" ]
        then
            nextFileToInclude="${CFG_IncludePath_LABEL}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @LABEL directive pointing towards ${nextFileToInclude}"

        # @MEDIUMTYPE inclusion directive
        elif [ "$directive" == "@MEDIUMTYPE" ]
        then
            nextFileToInclude="${CFG_IncludePath_MEDIUMTYPE}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @MEDIUMTYPE directive pointing towards ${nextFileToInclude}"

        # @MUSICALERA inclusion directive
        elif [ "$directive" == "@MUSICALERA" ]
        then
            nextFileToInclude="${CFG_IncludePath_MUSICALERA}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @MUSICALERA directive pointing towards ${nextFileToInclude}"

        # @ORCHESTRA inclusion directive
        elif [ "$directive" == "@ORCHESTRA" ]
        then
            nextFileToInclude="${CFG_IncludePath_ORCHESTRA}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @ORCHESTRA directive pointing towards ${nextFileToInclude}"

        # @RELEASECHANNEL inclusion directive
        elif [ "$directive" == "@RELEASECHANNEL" ]
        then
            nextFileToInclude="${CFG_IncludePath_RELEASECHANNEL}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @RELEASECHANNEL directive pointing towards ${nextFileToInclude}"

        # @RELEASESOURCE inclusion directive
        elif [ "$directive" == "@RELEASESOURCE" ]
        then
            nextFileToInclude="${CFG_IncludePath_RELEASESOURCE}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @RELEASESOURCE directive pointing towards ${nextFileToInclude}"

        # @SLICE inclusion directive
        elif [ "$directive" == "@SLICE" ]
        then
            nextFileToInclude="${CFG_IncludePath_SLICE}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @SLICE directive pointing towards ${nextFileToInclude}"

        # @SLICETYPE inclusion directive
        elif [ "$directive" == "@SLICETYPE" ]
        then
            nextFileToInclude="${CFG_IncludePath_SLICETYPE}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @SLICETYPE directive pointing towards ${nextFileToInclude}"

        # @WORK inclusion directive
        elif [ "$directive" == "@WORK" ]
        then
            nextFileToInclude="${CFG_IncludePath_WORK}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @WORK directive pointing towards ${nextFileToInclude}"

        # @WORKTYPE inclusion directive
        elif [ "$directive" == "@WORKTYPE" ]
        then
            nextFileToInclude="${CFG_IncludePath_WORKTYPE}/${value}.${CFG_FileExtensions_CVC}"
            [ "${OPT_Verbose}" ] && >&2 echo "INFO: Found a @WORKTYPE directive pointing towards ${nextFileToInclude}"

        # If the directive is unknown, we halt here.
        else
            >&2 echo "ERROR: Unknown inclusion directive '${directive}' in file '${targetCVCFile}':"
            >&2 echo "${line}"
            [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 4 || exit 4
        fi

        # Recursive call
        [ "${OPT_Verbose}" ] && >&2 echo "ACTION: Including file ${nextFileToInclude}"
        cvc::processFile "${nextFileToInclude}"
        [ "${OPT_Verbose}" ] && >&2 echo "INFO: Back to file ${currentFile}"

    #---------------------------------------------------------------------------
    # Else, if the line is a constant, we need to store it.
    #---------------------------------------------------------------------------
    elif [[ "${line}" =~ ^!.* ]] && [[ $line == *"="* ]]
    then

        # Generating constant properties
        fullConstant=${line%*=*}
        constant=${fullConstant%*:*}
        value=${line#$fullConstant=}
        constantUID=${constant#!}

        # Extracting constant language, if any
        if [[ $fullConstant == *":"* ]]
        then
            constantLanguage=${fullConstant#$constant:}
        else
            constantLanguage=""
        fi

        # We process the constant by default
        processConstant=1

        # We only process the constant if it is relevant to the target language
        if [ "${OPT_TargetLanguage}" ]
        then
            if [ "${constantLanguage}" ] && [ "${OPT_TargetLanguage}" != "${constantLanguage}" ]
            then
                [ "${OPT_Verbose}" ] && >&2 echo "INFO: Constant '${constantUID}' with language code '${constantLanguage}' was excluded due to language filtering."
                processConstant=0
            fi
        fi

        # Storing the constant
        if [ $processConstant -eq 1 ]
        then
            [ "${OPT_Verbose}" ] && >&2 echo "ACTION: Storing constant '${constantUID}' = '${value}'"
            CVC_Constants["${constantUID}"]="${value}"
        fi

    #---------------------------------------------------------------------------
    # Else, if the line is an alias, we need to convert it to regular tags.
    #---------------------------------------------------------------------------
    elif [[ "${line}" =~ ^\+.* ]] && [[ $line == *"="* ]]
    then

        # Generating alias properties
        fullAlias=${line%*=*}
        alias=${fullAlias%*:*}
        value=${line#$fullAlias=}

        # Performing constant subtitution
        value=$(cvc::substituteConstants "${value}")

        # Extracting subvalues
        IFS="|" read -ra values <<< "${value}"

        # Extracting alias language
        if [[ $fullAlias == *":"* ]]
        then
            aliasLanguage=${fullAlias#$alias:}
        else
            aliasLanguage=""
        fi

        # We process the alias by default
        processAlias=1

        # We only process the alias if it is relevant to the target language
        if [ "${OPT_TargetLanguage}" ]
        then
            if [ "${aliasLanguage}" ] && [ "${OPT_TargetLanguage}" != "${aliasLanguage}" ]
            then
                [ "${OPT_Verbose}" ] && >&2 echo "INFO: Alias '${alias}' with language code '${aliasLanguage}' was excluded due to language filtering."
                processAlias=0
            fi
        fi

        if [ "${processAlias}" -eq 1 ]
        then

            # +ALBUM --> Dynamically generated

            # +CHARACTER=FullName|ShortName
            if [ "$alias" == "+CHARACTER" ]
            then
                if [ "${values[1]}" ]
                then
                    CVCData_Characters+=("${values[1]}")
                    CVC_OutputBuffer+=("CHARACTER=${values[0]}")
                    CVC_OutputBuffer+=("CHARACTERSHORT=${values[1]}")
                elif [ "${values[0]}" ]
                then
                    CVCData_Characters+=("${values[0]}")
                    CVC_OutputBuffer+=("CHARACTER=${values[0]}")
                fi

            # +CHOIRNAME=Fullname|Sortname|Shortname
            elif [ "$alias" == "+CHOIRNAME" ]
            then
                if [ "${values[2]}" ]
                then
                    CVCData_Choirs+=("${values[2]}")
                    CVC_OutputBuffer+=("ENSEMBLE=${values[0]}")
                    CVC_OutputBuffer+=("ENSEMBLESORT=${values[1]}")
                    CVC_OutputBuffer+=("ENSEMBLESHORT=${values[2]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_Choirs+=("${values[0]}")
                    CVC_OutputBuffer+=("ENSEMBLE=${values[0]}")
                    CVC_OutputBuffer+=("ENSEMBLESORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                else
                    CVCData_Choirs+=("${values[0]}")
                    CVC_OutputBuffer+=("ENSEMBLE=${values[0]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                fi

            # +COMPOSERNAME=Fullname|Sortname|Shortname
            elif [ "$alias" == "+COMPOSERNAME" ]
            then
                if [ "${values[2]}" ]
                then
                    CVC_OutputBuffer+=("COMPOSER=${values[0]}")
                    CVC_OutputBuffer+=("COMPOSERSORT=${values[1]}")
                    CVC_OutputBuffer+=("COMPOSERSHORT=${values[2]}")
                    CVC_OutputBuffer+=("ALBUMARTISTSHORT=${values[2]}")
                    CVC_OutputBuffer+=("ALBUMARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ALBUM_ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUMARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUM ARTIST=${values[0]}")
                elif [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("COMPOSER=${values[0]}")
                    CVC_OutputBuffer+=("COMPOSERSORT=${values[1]}")
                    CVC_OutputBuffer+=("ALBUMARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ALBUM_ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUMARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUM ARTIST=${values[0]}")
                else
                    CVC_OutputBuffer+=("COMPOSER=${values[0]}")
                    CVC_OutputBuffer+=("ALBUM_ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUMARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ALBUM ARTIST=${values[0]}")
                fi

            # +CONDUCTORNAME=Fullname|Sortname|Shortname
            elif [ "$alias" == "+CONDUCTORNAME" ]
            then
                if [ "${values[2]}" ]
                then
                    CVCData_Conductors+=("${values[2]}")
                    CVC_OutputBuffer+=("CONDUCTOR=${values[0]}")
                    CVC_OutputBuffer+=("CONDUCTORSORT=${values[1]}")
                    CVC_OutputBuffer+=("CONDUCTORSHORT=${values[2]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_Conductors+=("${values[0]}")
                    CVC_OutputBuffer+=("CONDUCTOR=${values[0]}")
                    CVC_OutputBuffer+=("CONDUCTORSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                else
                    CVCData_Conductors+=("${values[0]}")
                    CVC_OutputBuffer+=("CONDUCTOR=${values[0]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                fi

            # +DISCNUMBER=Discnumber|Totaldiscs
            elif [ "$alias" == "+DISCNUMBER" ]
            then
                if [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("DISC=${values[0]}/${values[1]}")
                    CVC_OutputBuffer+=("DISCNUM=${values[0]}")
                    CVC_OutputBuffer+=("DISCNUMBER=${values[0]}")
                    CVC_OutputBuffer+=("TOTALDISCS=${values[1]}")
                    CVC_OutputBuffer+=("DISCTOTAL=${values[1]}")
                else
                    CVC_OutputBuffer+=("DISC=${values[0]}")
                    CVC_OutputBuffer+=("DISCNUM=${values[0]}")
                    CVC_OutputBuffer+=("DISCNUMBER=${values[0]}")
                fi

            # +FIRSTWORDS=FirstWords
            elif [ "$alias" == "+FIRSTWORDS" ]
            then
                if [ "${values[0]}" ]
                then
                    CVCData_Incipits+=("${values[0]}")
                    CVC_OutputBuffer+=("FIRSTWORDS=${values[0]}")
                fi

            # +INSTRUMENT=InstrumentName
            elif [ "$alias" == "+INSTRUMENT" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("INSTRUMENT=${values[0]}")
                fi

            # +INSTRUMENTALIST=Fullname|Sortname|Shortname|Instrument
            elif [ "$alias" == "+INSTRUMENTALIST" ]
            then
                if [ "${values[3]}" ]
                then
                    CVCData_Instrumentalists+=("${values[2]}")
                    CVC_OutputBuffer+=("INSTRUMENTALIST=${values[0]} (${values[3]})")
                    CVC_OutputBuffer+=("INSTRUMENTALISTSORT=${values[1]} (${values[3]})")
                    CVC_OutputBuffer+=("INSTRUMENTALISTSHORT=${values[2]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMERSHORT=${values[2]} (${values[3]})")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[2]}" ]
                then
                    CVCData_Instrumentalists+=("${values[2]}")
                    CVC_OutputBuffer+=("INSTRUMENTALIST=${values[0]}")
                    CVC_OutputBuffer+=("INSTRUMENTALISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("INSTRUMENTALISTSHORT=${values[2]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]}")
                    CVC_OutputBuffer+=("PERFORMERSHORT=${values[2]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_Instrumentalists+=("${values[0]}")
                    CVC_OutputBuffer+=("INSTRUMENTALIST=${values[0]}")
                    CVC_OutputBuffer+=("INSTRUMENTALISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                else
                    CVCData_Instrumentalists+=("${values[0]}")
                    CVC_OutputBuffer+=("INSTRUMENTALIST=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                fi

            # +KEY=MainKey|OpeningKey|ClosingKey
            elif [ "$alias" == "+KEY" ]
            then
                if [ "${values[2]}" ]
                then
                    CVC_OutputBuffer+=("CLOSINGKEY=${values[2]}")
                    CVC_OutputBuffer+=("OPENINGKEY=${values[1]}")
                    CVC_OutputBuffer+=("KEY=${values[1]}")
                    CVC_OutputBuffer+=("MAINKEY=${values[0]}")
                elif [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("OPENINGKEY=${values[1]}")
                    CVC_OutputBuffer+=("KEY=${values[1]}")
                    CVC_OutputBuffer+=("MAINKEY=${values[0]}")
                else
                    CVC_OutputBuffer+=("KEY=${values[0]}")
                    CVC_OutputBuffer+=("MAINKEY=${values[0]}")
                fi

            # +LABELNAME=LabelName
            elif [ "$alias" == "+LABELNAME" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("LABEL=${values[0]}")
                fi

            # +LYRICS=Lyrics
            elif [ "$alias" == "+LYRICS" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("LYRICS=${values[0]}")
                fi

            # +MEDIUMTYPE=ShortLabel|FullLabel
            elif [ "$alias" == "+MEDIUMTYPE" ]
            then
                if [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("MEDIUMTYPE=${values[1]}")
                    CVC_OutputBuffer+=("MEDIUMTYPESHORT=${values[0]}")
                elif [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("MEDIUMTYPE=${values[0]}")
                    CVC_OutputBuffer+=("MEDIUMTYPESHORT=${values[0]}")
                fi

            # +MUSICALERANAME=MusicalEraName
            elif [ "$alias" == "+MUSICALERANAME" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("GENRE=${values[0]}")
                fi

            # +ORCHESTRANAME=Fullname|Sortname|Shortname
            elif [ "$alias" == "+ORCHESTRANAME" ]
            then
                if [ "${values[2]}" ]
                then
                    CVCData_Orchestras+=("${values[2]}")
                    CVC_OutputBuffer+=("ORCHESTRA=${values[0]}")
                    CVC_OutputBuffer+=("ORCHESTRASORT=${values[1]}")
                    CVC_OutputBuffer+=("ORCHESTRASHORT=${values[2]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_Orchestras+=("${values[0]}")
                    CVC_OutputBuffer+=("ORCHESTRA=${values[0]}")
                    CVC_OutputBuffer+=("ORCHESTRASORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                else
                    CVCData_Orchestras+=("${values[0]}")
                    CVC_OutputBuffer+=("ORCHESTRA=${values[0]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                fi

            # +PERFORMED=PerformanceDate|PerformancePlace
            elif [ "$alias" == "+PERFORMED" ]
            then
                if [ "${values[1]}" ]
                then
                    CVCData_PerformanceYear+=("${values[0]:0:4}")
                    CVCData_PerformancePlace+=("${values[1]}")
                    CVC_OutputBuffer+=("DATE=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMANCEDATE=${values[0]}")
                    CVC_OutputBuffer+=("YEAR=${values[0]:0:4}")
                    CVC_OutputBuffer+=("PERFORMANCEYEAR=${values[0]:0:4}")
                    CVC_OutputBuffer+=("PERFORMANCEPLACE=${values[1]}")
                else
                    CVCData_PerformanceYear+=("${values[0]:0:4}")
                    CVC_OutputBuffer+=("DATE=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMANCEDATE=${values[0]}")
                    CVC_OutputBuffer+=("YEAR=${values[0]:0:4}")
                    CVC_OutputBuffer+=("PERFORMANCEYEAR=${values[0]:0:4}")
                fi

            # +RELEASECHANNEL=ReleaseChannel
            elif [ "$alias" == "+RELEASECHANNEL" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("RELEASECHANNEL=${values[0]}")
                fi

            # +RELEASED=ReleaseDate
            elif [ "$alias" == "+RELEASED" ]
            then
                if [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("RELEASEDATE=${values[0]}")
                    CVC_OutputBuffer+=("RELEASEYEAR=${values[0]:0:4}")
                fi

            # +RELEASEID=Id|IdType
            elif [ "$alias" == "+RELEASEID" ]
            then
                if [ "${values[1]}" ]
                then
                    # Barcode number
                    if [ "${values[1]^^}" == "BARCODE" ]
                    then
                        CVC_OutputBuffer+=("BARCODE=${values[1]}")
                    # Any other catalog number
                    else
                        CVC_OutputBuffer+=("CATALOGNUMBER=${values[1]} ${values[0]}")
                    fi
                elif [ "${values[0]}" ]
                then
                    (>&2 echo "WARNING: In file: '${targetCVCFile}':")
                    (>&2 echo "${1}")
                    (>&2 echo "Alias '+RELEASEID' requires exactly two arguments. The following line will be ignored:")
                fi

            # +RELEASESOURCE=ReleaseSource
            elif [ "$alias" == "+RELEASESOURCE" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("RELEASESOURCE=${values[0]}")
                fi

            # +RELEASEURL=UrlDescribingTheRelease
            elif [ "$alias" == "+RELEASEURL" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("URL=${values[0]}")
                fi

            # +SLICENUMBER=SliceNumber
            elif [ "$alias" == "+SLICENUMBER" ]
            then
                if [ "${values[0]}" ]
                then
                    CVCData_SliceNumbers+=("${values[0]}")
                    CVC_OutputBuffer+=("SLICENUMBER=${values[0]}")
                fi

            # +SLICETITLE=FullTitle|SortTitle|ShortTitle
            elif [ "$alias" == "+SLICETITLE" ]
            then
                if [ "${values[2]}" ]
                then
                    CVCData_SliceTitles+=("${values[0]}")
                    CVC_OutputBuffer+=("SLICETITLE=${values[0]}")
                    CVC_OutputBuffer+=("SLICETITLESORT=${values[1]}")
                    CVC_OutputBuffer+=("SLICETITLESHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_SliceTitles+=("${values[0]}")
                    CVC_OutputBuffer+=("SLICETITLE=${values[0]}")
                    CVC_OutputBuffer+=("SLICETITLESORT=${values[1]}")
                elif [ "${values[0]}" ]
                then
                    CVCData_SliceTitles+=("${values[0]}")
                    CVC_OutputBuffer+=("WORKSLICETITLE=${values[0]}")
                fi

            # +SLICETYPE=SLICETYPE
            elif [ "$alias" == "+SLICETYPE" ]
            then
                if [ "${values[0]}" ]
                then
                    CVCData_SliceTypes+=("${values[0]}")
                    CVC_OutputBuffer+=("SLICETYPE=${values[0]}")
                    CVC_OutputBuffer+=("GENRE=${values[0]}")
                fi

            # +SOLOIST=Fullname|Sortname|Shortname|Instrument
            elif [ "$alias" == "+SOLOIST" ]
            then
                if [ "${values[3]}" ]
                then
                    CVCData_Instrumentalists+=("${values[2]}")
                    CVCData_Soloists+=("${values[2]}")
                    CVC_OutputBuffer+=("SOLOIST=${values[0]} (${values[3]})")
                    CVC_OutputBuffer+=("SOLOISTSORT=${values[1]} (${values[3]})")
                    CVC_OutputBuffer+=("SOLOISTSHORT=${values[2]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]} (${values[3]})")
                    CVC_OutputBuffer+=("PERFORMERSHORT=${values[2]} (${values[3]})")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[2]}" ]
                then
                    CVCData_Instrumentalists+=("${values[2]}")
                    CVCData_Soloists+=("${values[2]}")
                    CVC_OutputBuffer+=("SOLOIST=${values[0]}")
                    CVC_OutputBuffer+=("SOLOISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("SOLOISTSHORT=${values[2]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]}")
                    CVC_OutputBuffer+=("PERFORMERSHORT=${values[2]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTISTSHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_Instrumentalists+=("${values[0]}")
                    CVCData_Soloists+=("${values[0]}")
                    CVC_OutputBuffer+=("SOLOIST=${values[0]}")
                    CVC_OutputBuffer+=("SOLOISTSORT=${values[1]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMERSORT=${values[1]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                    CVC_OutputBuffer+=("ARTISTSORT=${values[1]}")
                else
                    CVCData_Instrumentalists+=("${values[0]}")
                    CVCData_Soloists+=("${values[0]}")
                    CVC_OutputBuffer+=("SOLOIST=${values[0]}")
                    CVC_OutputBuffer+=("PERFORMER=${values[0]}")
                    CVC_OutputBuffer+=("ARTIST=${values[0]}")
                fi

            # +TRACKNUMBER=Tracknumber|Totaltracks
            elif [ "$alias" == "+TRACKNUMBER" ]
            then
                if [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("TRACK=${values[0]}/${values[1]}")
                    CVC_OutputBuffer+=("TRACKNUM=${values[0]}")
                    CVC_OutputBuffer+=("TRACKNUMBER=${values[0]}")
                    CVC_OutputBuffer+=("TOTALTRACKS=${values[1]}")
                    CVC_OutputBuffer+=("TRACKTOTAL=${values[1]}")
                else
                    CVC_OutputBuffer+=("TRACK=${values[0]}")
                    CVC_OutputBuffer+=("TRACKNUM=${values[0]}")
                    CVC_OutputBuffer+=("TRACKNUMBER=${values[0]}")
                fi

            # +TRACKTITLE --> Dynamically generated

            # +WORKID=Cataloguenumber|Cataloguename
            elif [ "$alias" == "+WORKID" ]
            then
                if [ "${values[1]}" ]
                then
                    CVC_OutputBuffer+=("CATALOGID=${values[1]} ${values[0]}")
                else
                    CVC_OutputBuffer+=("CATALOGID=${values[0]}")
                fi

            # +WORKSUBTITLE=Subtitle
            elif [ "$alias" == "+WORKSUBTITLE" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("WORKSUBTITLE=${values[0]}")
                fi

            # +WORKTITLE=Fulltitle|Sorttitle|Shorttitle
            elif [ "$alias" == "+WORKTITLE" ]
            then
                if [ "${values[2]}" ]
                then
                    CVCData_WorkTitle+=("${values[0]}")
                    CVCData_WorkTitleSort+=("${values[1]}")
                    CVC_OutputBuffer+=("WORKTITLE=${values[0]}")
                    CVC_OutputBuffer+=("WORKTITLESORT=${values[1]}")
                    CVC_OutputBuffer+=("WORKTITLESHORT=${values[2]}")
                elif [ "${values[1]}" ]
                then
                    CVCData_WorkTitle+=("${values[0]}")
                    CVCData_WorkTitleSort+=("${values[1]}")
                    CVC_OutputBuffer+=("WORKTITLE=${values[0]}")
                    CVC_OutputBuffer+=("WORKTITLESORT=${values[1]}")
                else
                    CVCData_WorkTitle+=("${values[0]}")
                    CVC_OutputBuffer+=("WORKTITLE=${values[0]}")
                fi

            # +WORKTYPE=WorkType
            elif [ "$alias" == "+WORKTYPE" ]
            then
                if [ "${values[0]}" ]
                then
                    CVC_OutputBuffer+=("WORKTYPE=${values[0]}")
                    CVC_OutputBuffer+=("GENRE=${values[0]}")
                fi

            # If the alias is unknown, we halt here.
            else
                >&2 echo "ERROR: Unknown alias '${alias}' in file '${targetCVCFile}':"
                >&2 echo "${line}"
                [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 5 || exit 5
            fi
        fi

    #---------------------------------------------------------------------------
    # If the line is blank or a commentary, we just ignore it.
    #---------------------------------------------------------------------------
    elif [ "${line}" == "" ] || [[ "${line}" =~ ^#.* ]]
    then
        :

    #---------------------------------------------------------------------------
    # If the line is a directive, we just ignore it.
    #---------------------------------------------------------------------------
    elif [[ "${line}" =~ ^\..* ]]
    then
        :

    #---------------------------------------------------------------------------
    # Else, if the line is valid, we just output it as is.
    #---------------------------------------------------------------------------
    elif [[ "${line}" == *"="* ]]
    then
        CVC_OutputBuffer+=("$line")

    else
        >&2 echo "ERROR: Invalid line in file '${targetCVCFile}':"
        >&2 echo "${line}"
        [[ "${BASH_SOURCE[0]}" != "${0}" ]] && return 6 || exit 6
    fi
}

function cvc::processFile {

    # The currentFile variable needs to survive recursive calls.
    local currentFile="${1}"

    # Processing lines.
    while IFS='' read -r line || [[ -n "$line" ]]; do
        processLine "${line}"
    done < "${currentFile}"
}

################################################################################
# Generating ALBUM and ALBUMTITLE
################################################################################

# Format: WorkTitle (Orchestras/Choirs/Conductors/Soloists, Year)
function cvc::makeDynamicAlbumTitle {
    # Initiating variables
    local _album_suffix=""

    # Adding orchestras to the album suffix
    if [ ! "${CVCData_Orchestras}" == "" ]
    then
        for orchestra in "${CVCData_Orchestras[@]}"; do
            _album_suffix+="${orchestra}${CFG_CVCExpand_DefaultDelimiter}"
        done
    fi

    # Adding choirs to the album suffix
    if [ ! "${CVCData_Choirs}" == "" ]
    then
        for choir in "${CVCData_Choirs[@]}"; do
            _album_suffix+="${choir}${CFG_CVCExpand_DefaultDelimiter}"
        done
    fi

    # Adding soloists to the album suffix
    if [ ! "${CVCData_Soloists}" == "" ] && [ "${#CVCData_Soloists[@]}" -lt 3 ]
    then
        for soloist in "${CVCData_Soloists[@]}"; do
            _album_suffix+="${soloist}${CFG_CVCExpand_DefaultDelimiter}"
        done
    fi

    # Adding conductors to the album suffix
    if [ ! "${CVCData_Conductors}" == "" ]
    then
        for conductor in "${CVCData_Conductors[@]}"; do
            _album_suffix+="${conductor}${CFG_CVCExpand_DefaultDelimiter}"
        done
    fi

    # Adding performance year to the album suffix
    if [ "${CVCData_PerformanceYear}" ]
    then
        _album_suffix="${_album_suffix%${CFG_CVCExpand_DefaultDelimiter}}, ${CVCData_PerformanceYear}"
    else
        _album_suffix="${_album_suffix%${CFG_CVCExpand_DefaultDelimiter}}"
    fi

    if [ ! "${CVCData_WorkTitle}" == "" ]
    then
        CVC_OutputBuffer+=("ALBUM=${CVCData_WorkTitle} (${_album_suffix})")
        CVC_OutputBuffer+=("ALBUMTITLE=${CVCData_WorkTitle} (${_album_suffix})")
    fi

    if [ ! "${CVCData_WorkTitleSort}" == "" ]
    then
        CVC_OutputBuffer+=("ALBUMSORT=${CVCData_WorkTitleSort} (${_album_suffix})")
    fi
}

################################################################################
# Generating TITLE and TRACKTITLE
################################################################################

# Format: SLICENUMBERs SLICETYPE (Characters) WorkSliceTitle
function cvc::makeDynamicTrackTitle {

    # Initiating variables
    local _trackTitle=""

    # If workslice numbers are defined, we show them at the beginning of the title
    if [ ! "${CVCData_SliceNumbers}" == "" ]
    then
        for SLICENUMBER in "${CVCData_SliceNumbers[@]}"; do
            _trackTitle+="${SLICENUMBER}${CFG_CVCExpand_DefaultDelimiter}"
        done
        _trackTitle="${_trackTitle%${CFG_CVCExpand_DefaultDelimiter}} "
    fi

    # If there is a slice type, we specify it here
    if [ ! "${CVCData_SliceTypes}" == "" ]
    then
        for SLICETYPE in "${CVCData_SliceTypes[@]}"; do
            _trackTitle+="${SLICETYPE}${CFG_CVCExpand_DefaultDelimiter}"
        done
        _trackTitle="${_trackTitle%${CFG_CVCExpand_DefaultDelimiter}} "
    fi

    # If characters are defined, we show them between braces
    if [ ! "${CVCData_Characters}" == "" ]
    then
        # We keep a trace of the characters we already shew to avoid duplicates.
        characterLog=()

        # Characters are shown between braces
        _trackTitle+="("

        for character in "${CVCData_Characters[@]}"; do
            # Checking whether the current character was already shown
            skip=0
            for loggedCharacter in "${characterLog[@]}"; do
                if [ "${loggedCharacter}" == "${character}" ]
                then
                    skip=1
                fi
            done

            # Showing character
            if [ ${skip} -eq 0 ]
            then
                characterLog+=("${character}")
                _trackTitle+="${character}${CFG_CVCExpand_DefaultDelimiter}"
            fi
        done

        # Closing braces
        _trackTitle="${_trackTitle%${CFG_CVCExpand_DefaultDelimiter}}) "
    fi

    # Next comes the slice title. If a title is defined, we use it.
    if [ ! "${CVCData_SliceTitles}" == "" ]
    then
        for title in "${CVCData_SliceTitles[@]}"; do
            _trackTitle+="${title}${CFG_CVCExpand_DefaultDelimiter}"
        done
        _trackTitle="${_trackTitle%${CFG_CVCExpand_DefaultDelimiter}} "

    # If no title is present, we try to use the first words as a title
    elif [ ! "${CVCData_Incipits}" == "" ]
    then
        for firstwords in "${CVCData_Incipits[@]}"; do
            _trackTitle+="'${firstwords}'${CFG_CVCExpand_DefaultDelimiter}"
        done
        _trackTitle="${_trackTitle%${CFG_CVCExpand_DefaultDelimiter}}"

    # If we land here, the track is untitled.
    else
        _trackTitle="${CFG_CVCExpand_UntitledTracks}"
    fi

    CVC_OutputBuffer+=("TITLE=${_trackTitle}")
    CVC_OutputBuffer+=("TRACKTITLE=${_trackTitle}")
}

################################################################################
# Outputing results
################################################################################

function cvc::dump {

    # We keep a log of all lines already shown to prevent outputing the same line twice.
    local _outputLog=()

    for line in "${CVC_OutputBuffer[@]}"; do

        # We do not skip the line by default
        skip=0

        # Checking whether the current line is a duplicate
        for loggedLine in "${_outputLog[@]}"; do
            if [ "${loggedLine}" == "${line}" ]
            then
                skip=1
            fi
        done

        # We log and output the line
        if [ ${skip} -eq 0 ]
        then
            _outputLog+=("${line}")
            echo "${line}"
        fi

    done
}

################################################################################
# Main entry point
################################################################################

cvc::processFile "${targetCVCFile}"
cvc::makeDynamicAlbumTitle
cvc::makeDynamicTrackTitle
cvc::dump
